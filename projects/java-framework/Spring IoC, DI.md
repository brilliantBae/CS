### IoC, 제어의 역전

*제어의 역전이라는 것은 무엇일까?*

제어의 역전이라는 것은 간단하게 말하면 나에 대한 제어를 다른 대상이 맡는다라고 표현할 수 있다.

*IoC는 어떤 장점때문에 쓰이는 것일까?*

IoC 를 적용하면 **설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아지기** 때문에 여러 곳에서 쓰인다고 한다. 

IoC가 적용된 대표적인 예를 들면, 서블릿이 서블릿 컨테이너에 의해 관리되는 경우와 빈 오브젝트와 이를 관리하는 스프링 컨테이너 등이 있다. 서블릿의 경우에 자기 자신을 직접 실행하는 main() 메소드가 존재하지 않는 것을 보면 IoC 가 적용되었다는 것을 쉽게 알 수 있다.

스프링 프레임워크에서 제어의 역전 개념이 적용된 부분은 앞에서 말했듯이 스프링이 관리하는 오브젝트인 빈과 스프링의 관계이다. 그래서 스프링을 IoC 컨테이너라고도 부르고 구체적으로 스프링에서는 빈들을 제어하는 역할을 가진 오브젝트를 2가지 종류로 제공하고 있다. 바로 BeanFactory 와 ApplicationContext 라고 하는 오브젝트인데 이 두개는 거의 동일한 것으로 취급해도 되지만 ApplicationContext 의 경우에는 빈의 생성, 빈들간의 관계설정 뿐만이 아니라 애플리케이션 전반의 모든 컴포넌트들의 제어까지 담당하기 때문에 단순히 빈의 생성과 관계설정만 담당하는 BeanFactory 의 개념보다는 확장된 개념의 오브젝트라고 할 수 있다.

ApplicationContext가 빈들을 관리하는 방식을 살펴보면, 

1. 먼저 `ApplicationContext ac = new ApplicationContext(MyConfiguration.class);` 와 같이 참고할 설정 정보를 등록하고 빈으로 등록할 클래스들의 리스트를 만들어 둔다. 
2. 그 다음, 클라이언트로부터 특정 빈에 대한 요청인  `getBean()` 이 오면 빈 리스트에서 요청한 이름이 있는지 확인한 다음, 있으면 빈을 생성하는 메소드를 호출해 빈을 생성한 다음 클라이언트로 빈을 응답으로 돌려준다.

**ApplicationContext가 필요한 이유**는 참고해야 할 설정파일이 여러개가 되더라도 빈을 요청하는 클라이언트 쪽에서는 전혀 영향을 받지 않고 일관되게 `getBean()` 요청을 통해서 빈을 획득할 수 있고, 아까도 언급했듯이 ApplicationContext가 담당하는 역할이 빈의 생성, 제어 뿐 아니라 다른 컴포넌트들에 대한 제어도 담당하고 있기 때문이다.

**싱글톤 레지스트리로서의 애플리케이션 컨텍스트** 

*스프링은 왜 싱글톤 형태로 빈들을 관리하는가?*

ApplicationContext는 default로 빈들을 싱글톤 형태로 관리하고 있는데, 먼저 빈들이 싱글톤 형태, 즉, 한번만 객체로 생성된 이후에 재사용되는 방식으로 제공되어야 하는 이유는 스프링이 적용되는 환경이 서버 환경이기 때문에 여러 클라이언트 요청이 올 때마다 오브젝트를 새로 만들어서 제공하는 방식을 이용하게 되면 서버에 부하가 걸리기 때문이다. 서블릿 같은경우에도 톰캣에 의해 싱글톤 형태로 제공이 되는 예라고 할 수 있다. 

*싱글톤 형태라고 했는데 일반적인 싱글톤 패턴하고 다른 점이 무엇인가?*

디자인 패턴에서의 싱글톤 패턴은 생성자를 private 으로 만들고, 멤버변수로 자신의 타입과 동일한 타입의 변수를 설정하고 `getInstance()` 라는 메소드를 통해 외부 클래스에서 이 메소드를 통해서만 인스턴스를 얻을 수 있도록 강제하는 패턴이다. 그런데 이 싱글톤 패턴을 이용하게 되면 여러가지 단점이 있는데, 일단 private 생성자를 갖고있기 때문에 상속이 불가능해서 객체지향적인 설계를 하기에 제한이 있고, 인스턴스를 외부에서 생성하는것이 불가능하기 때문에 테스트하기가 어렵다는 점 등의 단점들이 존재한다.

그런데 스프링이 빈들을 직접 관리하게 되면 클래스 자체내에서 싱글톤 패턴을 구현하지 않더라도 싱글톤 형태로 제공이 되기 때문에 이런 단점들을 경험하지 않아도 된다. 다시 말하면, 스태틱 메소드와 private 생성자를 가지지 않은 평범한 자바 클래스도 스프링을 통해서 싱글톤 형태로 애플리케이션에 제공될 수 있다는 뜻이다. 이것이 스프링이 빈을 관리함으로써 얻을 수 있는 하나의 장점이라고 할 수 있다.

*어쨌든 JVM은 멀티쓰레드 환경이기 때문에 싱글톤으로 제공이 되면  발생하는 문제가 있을 것이다. 문제가 무엇이고 어떻게 해결해야하나?*

JVM 이 OS 로부터 할당받는 메모리 영역인 Runtime Data Area 에서 각 스레드가 공유하는 영역은 힙, Method 영역이고 힙에 저장되는 변수는 인스턴스 변수, Method 영역에 저장되는 변수는 static 변수이다. 또한 JVM stack 은 스레드마다 독자적으로 관리하는 영역이고, 여기에는 지역변수, 메소드의 파라미터 등이저장되는 공간이다. 참고 그림은 아래와 같다.



![image](https://user-images.githubusercontent.com/23162178/41199151-5d2b4b9e-6cc8-11e8-8a96-bcf720a8ec9e.png)



그래서 빈으로 제공될 클래스를 구성할 때는 각 스레드가 동시에 접근할 가능성이 있는 static 변수나 인스턴스 변수는 두지 않고 메소드의 파라미터나 지역변수로 두어서 데이터 무결성을 지키도록 해야한다. 

그러나 인스턴스 변수가 존재해도 되는 경우가 있는데 이는 아래와 같이 스프링이 관리하는 빈 타입의 변수일 경우에는 ApplicationContext 에 의해 한번만 생성이 되고 재사용되는 방식이기 때문에 생성 이후에 상태가 변경될 일이 없다. 그래서 이 경우에는 인스턴스 변수로 놓아도 괜찮은 것이다. 

<img width="689" alt="2018-06-10 4 21 25" src="https://user-images.githubusercontent.com/23162178/41199309-5bde6094-6cca-11e8-894f-47ddcf9b698d.png">

또한 읽기 전용의 변수인 경우 인스턴스 변수 형태로 존재해도 괜찮다.



*스프링 빈의 스코프에는 어떤 것이 있는가?*

스프링 빈의 스코프는 기본적으로 싱글톤 스코프인데 이는 스프링 컨테이너가 존재하는 동안 계속 유지된다. 프로토타입 스코프라는 것도 있는데 이는 빈에 대한 요청이 있을 때마다 객체를 새로 생성해서 클라이언트에게 제공한다. 이 이외에 HTTP 요청이 있을때마다 생성되는 요청(request) 스코프가 있고, 서블릿의 세션 스코프와 유사한 세션(session) 스코프가 있다.

### DI 의존관계 주입

*의존관계라는 것이 무엇인가?*

프로그래밍 분야에서 클래스들 간의 의존관계가 있다라고 하면, 예를 들어 '*A가 B에 의존한다* ' 고 하면 이 뜻은  B가 변하면 그 변화가 A에 영향을 미친다는 뜻이다. 

*의존관계 주입(DI) 라는 것은 무엇인가?*

클래스들간의 의존관계를 의존하는 쪽에서 자체적으로 의존관계를 해결할 수 있지만 이 방법말고 외부에서 의존관계에 있는 오브젝트의 레퍼런스를 제공받아서 해결하는 방식을 의존관계 주입(DI)이라고 말한다. DI도 결국은 IoC의 일종이다. 일반적인 DI 의 개념은 이렇지만 스프링에서는 단순히 외부에서 의존관계를 주입해주는 것 뿐만 아니라 추가적인 조건아래에서 DI 를 해주기 때문에 의존성의 자체적 해결보다 DI 를 통해서 

스프링에서는 런타임 

*IoC와 DI 의 관계는?*



클래스들간의 의존관계를 의존하는 쪽에서 자체적으로 의존관계를 해결할 수 있지만 그것말고 

*그럼 의존관계를 자체적으로 해결하는 방식보다 DI가  좋은 점은 무엇인가?, 내 경험*

내가 경험한 DI 의 장점은 테스트 코드 짜기가 유용했다. 



