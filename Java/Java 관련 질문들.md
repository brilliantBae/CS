## Java 관련 질문들

**Object 클래스의 메소드들**

Object 클래스는 모든 클래스의 슈퍼 클래스인 클래스이다. 

* `toString()` : 객체에 대한 정보를 문자열로 나타내기 위한 메소드. 개발자의 의도대로 오버라이드해서 사용할 수 있다. 자바는 특별하게 어떤 객체를 System.out.print 로 호출하면 자동으로 `toString()` 이 호출되도록 하고 있다.

* `equals(Object o)` : 객체와 객체가 논리적으로 동등한지 비교하기 위해서 쓰이는 메소드이다. 기본으로 구현되어 있는 equals 를 사용하는 경우, 그 결과가 == 와 같기 때문에 동일 객체가 아닌 이상 false가 리턴된다. 개발자의 의도대로 객체를 비교하게 하려면 이 메소드를 오버라이드해서 의도대로 재정의하면 된다.

* `hashcode()` : 객체와 객체의 논리적 동등비교를 위해 추가적으로 필요한 메소드로 내부적으로는 객체의 메모리 주소를 이용해 해시코드를 리턴하는 메소드이다. 그렇기 때문에 기본적으로 동일한 객체가 아니면 false를 리턴한다. 해쉬함수를 사용하는 특정 자료구조 **HashSet, HashMap, Hashtable** 은  객체들의 동등비교를 할 때 먼저 객체의 hashcode() 리턴값을 비교하고 동일하면 equals() 리턴값을 비교하여 true 면 동일하다고 판단하고, 그 반대면 동일하지 않다고 판단한다.

  

**final Keyword**

* final class : 다른 클래스가 상속하지 못한다.
* final method : 다른 메소드가 오버라이드 할 수 없다.
* final variable : 변경 불가능한 상수라는 의미이다.

**Overriding & Overloading**

* Overriding : 같은 메소드 이름, 같은 파라미터 목록으로(동일한 메소드 정의) 상위클래스의 메소드를 재정의 하는 것을 말한다.
* Overloading : 같은 메소드 이름, 다른 파라미터 목록으로 다수의 메소드를 중복 정의하는 것을 말한다.

**Access Modifier**

private -> default -> protected -> public  순으로 많은 접근을 허용한다.

* private : 해당 클래스 내에서만 접근가능
* default : 해당 패키지 내에서만 접근가능
* protected : 같은 패키지 내의 클래스 **또는** 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근 가능
* public : 어떤 클래스라도 접근가능

**Wrapper class**

기본 자료형(primitive data type)을 객체로 사용해야 하는 경우에 기본형 타입을 객체로 포장해야 한다. 이때 사용하는 것이 wrapper class 이다. 대표적인 사용 예는 컬렉션에서 제네릭을 사용하기 위해 이 wrapper class 를 사용한다. 

**AutoBoxing, AutoUnboxing**

JDK 1.5부터  AutoBoxing, AutoUnboxing 이 지원되었다.

Auto boxing : 기본 자료형을 wrapper 객체로 자동변경하는 기능

```java
List<Integer> lists = new ArrayList<>();
lists.add(1);
```

add 연산을 할때 AutoBoxing 이 동작하기 때문에 Integer wrapper class 로 감싸서 넣어주지 않아도 되는것이다.

**Generic**

타입을 파라미터로 가진 클래스와 인터페이스를 말하며, 컴파일 타임시에 타입 체크를 해주기 때문에 에러를 사전에 방지할 수 있고, 타입 casting 을 제거해주어서 프로그램 성능을 향상시킨다. (컬렉션 프레임워크 사용시에)

**String, StringBuffer, StringBuilder**

**String**

문자열은 String 객체로 생성되고 변수는 String 객체를 참조한다. 

```java
String name = "java";
```

변수인 name 은 JVM stack 영역에 저장되고, 문자열 리터럴인 "java"는 힙 영역에 객체로 생성된다. 변수는 해당 객체의 주소값을 저장하고 있다.

```java
String object1 = "java";
String object2 = "java";
String object3 = new String("java");
```

자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어있다. 그러므로 object1과 object2는 동일한 객체를 참조하고 있고, object3 는 새로 생성한 객체를 참조하고 있다. 즉, 위 예시에서 존재하는 객체의 총 개수는 2개 이다.

*String 객체가 이렇게 디자인 되어 있는 이유는 무엇일까?*

java에서 String 은 immutable 이다. 간단하게 말하면 한번 값이 할당되면 값을 변경할 수 없다. immutable 한 객체들은 값을 변경할 수 없으므로 thread-safe 하다. 

**StringBuffer**, **StringBuilder**

StringBuffer 와 StringBuilder 는 문자열을 이어붙이는(concat) 방식이 String 과 다르다. String 은 immutable 하므로 문자열을 이어붙일 때 새 String 객체를 생성하지만 이 둘은 기존 객체의 버퍼 크기를 늘리며 문자열을 추가한다. 다시 말해서 이 둘은 mutable 하다.

*그럼 이 둘의 차이점은 무엇인가?*

이 둘은 멀티스레딩 환경에서 동기화 문제를 처리하는 방식에 있어서 차이가 있다.

StringBuffer 의 경우 내부 구현을 보면 알겠지만 각 메소드 별로 synchronized keyword 가 존재한다. 즉, thread-safe 하다는 얘기이다. 반대로 StringBuilder 는 thread-safe 하지 않다. 그래서 더 빠른 성능을 보인다. 멀티스레딩 환경이 아닐 경우에 StringBuffer 를 사용하면 성능이 안좋아질 수 있기 때문에 이 점을 고려해 사용해야 한다. 

JDK 1.5부터 String 을 사용하더라도 컴파일 단계에서 StringBuilder 로 컴파일 되게 만들었다. 그래서 따로 StringBuilder를 사용하지 않아도 된다.



**Java Collections Framework**

객체들을 모아서 저장하기 위한 목적으로 존재하며 주요 인터페이스로는 List, Set, Map이 있다. 각 인터페이스별로 사용할 수 있는 컬렉션들의 특징은 List 계열의 컬렉션들은 저장할 때 순서가 유지되고 중복값 저장이 가능하다. Set 계열의 컬렉션들은 저장할 때 순서가 유지되지 않고 중복값을 저장할 수 없다. Map 계열의 컬렉션들은 저장될때 키와 value 쌍으로 저장되고, key는 중복되면 안되고 value는 중복이 가능하다.

각 인터페이스의 구현체들을 말하자면, List 계열의 컬렉션에는 ArrayList, Vector, LinnkedList 가 있다. 

**Abstract class VS interface**

*추상 클래스와 인터페이스의 차이 및 존재 이유를 설명해보세요.*

추상 클래스는 클래스 내에 추상 메소드가 하나 이상 포함된 클래스이고, 인터페이스는 모든 메소드가 추상 메소드이고 public 정적 상수만 가질 수 있다.

추상 클래스와 인터페이스는 존재 목적이 다르다.

추상클래스는 그 추상클래스를 상속받아서 기능을 재사용하거나 확장하기 위해서 사용되고, 인터페이스의 경우에는 이를 구현한 하위 클래스들에게 기능 구현을 강제해 동일한 동작을 약속하기 위해서 존재한다. 

**객체지향 5원칙**

* SRP(단일 책임 원칙) : 한 클래스는 한 역할만 담당해야하고, 클래스가 변경되어야 하는 이유는 한가지어야 한다. 단일 책임 원칙 위반한 대표적인 증거는 if문의 존재이다. 이때는 추상메소드로 만들어서 그 클래스를 상속하는 하위 클래스에서 구현을 다르게 하면 if문을 없앨 수 있다.
* OCP(개방 폐쇄의 원칙) : 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다. JDBC 인터페이스, 그 구현 클래스인 드라이버 클래스들.
* LSP(리스코프 치환 원칙) : 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야한다. 상속과 인터페이스 구현이 제대로 적용된 경우에는 이 원칙을 지키고 있다고 말할 수 있다.
* ISP(인터페이스 분리 원칙) : 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 있더라도 영향을 받지 않도록 만들어야 한다.
* DIP(의존 역전 원칙) : 의존할 때는 잘 변하지 않는 것에 의존해야 한다는 원칙이다. 변하기 쉬운 것에 의존하게 되면 그 변화에 자기 자신이 영향을 받기 때문이다. 상위 클래스일수록, 인터페이스일수록, 추상클래스일수록 변할 가능성이 낮기 때문에 이들에게 의존하는 편이 좋다.

**Reflection**

**객체를 통해 클래스의 정보**를 분석해내는 프로그래밍 기법이다.

자바 클래스 파일은 바이트 코드로 컴파일되어 method 영역에 위치하기 때문에 바이트 코드를 통해 클래스 정보를 알아낼 수 있다. 그렇기 때문에 타입을 몰라도 객체의 메서드를 호출할 수 있다. 